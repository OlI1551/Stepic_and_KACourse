/*
Iterator и Iterable
Сначала поговорим о базовых интерфейсах, от которых зависит работа всех остальных, а потом перейдем к более специфичным.

Iterable
Это основной, корневой интерфейс. От него наследуются все прочие. Он означает, что объект итерируемый, то есть перечислимый.
Так называются сущности, элементы которых можно перечислять по очереди: по индексам, названию или расположению в структуре.
То есть это практически все сложные объекты, где хранится множество значений.

У Iterable и, соответственно, у всех интерфейсов, которые от него наследуются, есть метод iterator().
Он возвращает итератор — специальную сущность-«перечислитель», своеобразный курсор, который указывает на тот или иной объект.
С помощью итераторов мы получаем доступ к разным значениям коллекции.

Есть только одна сущность, которая не наследуется от Iterable, но тем не менее часто упоминается вместе с коллекциями
и входит в Collections Framework. Это Map, и мы поговорим об этом позже.

Iterator
У итератора тоже есть свой интерфейс. Он описывает такие курсоры и возможности, которые у них есть.
Методы итератора — это next(), который возвращает следующий элемент, remove(), который удаляет текущий элемент,
и hasNext() — он показывает, существует ли в коллекции следующий элемент.
Рассмотрим пример использования итератора. Создадим список имен, после чего получим итератор коллекции,
пройдемся по всем элементам и удалим всех "mike".

final List<String> names = new ArrayList<>(List.of("mark", "mike", "kate"));
final Iterator<String> iterator = names.iterator();
while (iterator.hasNext()) {
    final String name = iterator.next();
    	if ("mike".equals(name)) {
    	iterator.remove();
	}
}
System.out.println(names); // [mark, kate]


Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator().
Он возвращает итератор - то есть объект, реализующий интерфейс Iterator.

Интерфейс Iterator имеет следующее определение:

public interface Iterator <E>{

    E next();
    boolean hasNext();
    void remove();
}
Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить следующий элемент.
С помощью метода hasNext() можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции.
И если элементы еще имеются, то hasNext() вернет значение true. Метод hasNext() следует вызывать перед методом next(),
так как при достижении конца коллекции метод next() выбрасывает исключение NoSuchElementException. И метод remove() удаляет текущий элемент, который был получен последним вызовом next().

Используем итератор для перебора коллекции ArrayList:
 */
import java.util.*;

public class ex31_9Iterator {

    public static void main(String[] args) {

        ArrayList<String> states = new ArrayList<String>();
        states.add("Germany");
        states.add("France");
        states.add("Italy");
        states.add("Spain");

        Iterator<String> iter = states.iterator();
        while(iter.hasNext()){

            System.out.println(iter.next());
        }


/*
Интерфейс Iterator предоставляет ограниченный функционал.
Гораздо больший набор методов предоставляет другой итератор - интерфейс ListIterator.
Данный итератор используется классами, реализующими интерфейс List, то есть классами LinkedList, ArrayList и др.

Интерфейс ListIterator расширяет интерфейс Iterator и определяет ряд дополнительных методов:
void add(E obj): вставляет объект obj перед элементом, который должен быть возвращен следующим вызовом next()
boolean hasNext(): возвращает true, если в коллекции имеется следующий элемент, иначе возвращает false
boolean hasPrevious(): возвращает true, если в коллекции имеется предыдущий элемент, иначе возвращает false
E next(): возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение NoSuchElementException
E previous(): возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение NoSuchElementException
int nextIndex(): возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка
int previousIndex(): возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1
void remove(): удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов next() или previous(), иначе будет сгенерировано исключение IlligalStateException
void set(E obj): присваивает текущему элементу, выбранному вызовом методов next() или previous(), ссылку на объект obj

Используем ListIterator:
*/


        ArrayList<String> statesNew = new ArrayList<String>();
        statesNew.add("Germany");
        statesNew.add("France");
        statesNew.add("Italy");
        statesNew.add("Spain");

        ListIterator<String> listIter = statesNew.listIterator();

        while(listIter.hasNext()){

            System.out.println(listIter.next());
        }
        // сейчас текущий элемент - Испания
        // изменим значение этого элемента
        listIter.set("Португалия");
        // пройдемся по элементам в обратном порядке
        while(listIter.hasPrevious()){

            System.out.println(listIter.previous());
        }
    }
}
