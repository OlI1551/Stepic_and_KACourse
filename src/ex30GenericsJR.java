import java.util.*;

public class ex30GenericsJR {
//    public static void main(String []args){
//        List list = new ArrayList();
//        list.add("Hello");
//        String text = list.get(0) + ", world!";
//        System.out.print(text);
//    }
//    Этот код выполнится хорошо. Но что если к нам пришли и сказали, что фраза "Hello, world!"
//    избита и можно вернуть только Hello?
//    Удалим из кода конкатенацию со строкой ", world!".
//    Казалось бы, что может быть безобиднее? Но на деле мы получим ошибку ПРИ КОМПИЛЯЦИИ:
//    error: incompatible types: Object cannot be converted to String

    //    Всё дело в том, что в нашем случае List хранит список объектов типа Object.
//    Так как String — наследник для Object (ибо все классы неявно наследуются в Java от Object),
//    то требует явного приведения, чего мы не сделали.
//    А при конкатенации для объекта будет вызван статический метод String.valueOf(obj),
//    который в итоге вызовет метод toString для Object.
//    То есть List у нас содержит Object.
//    Выходит, там где нам нужен конкретный тип, а не Object,
//    нам придётся самим делать приведение типов:
//    public static void main(String[] args) {
//        List list = new ArrayList();
//        list.add("Hello!");
//        list.add(123);
//        for (Object str : list) {
//            System.out.println((String) str);
//        }
//    }
//  Однако, в данном случае, т.к. List принимает список объектов, он хранит не только String, но и Integer.
//  Но самое плохое, в этом случае компилятор не увидит ничего плохого.
//  И тут мы получим ошибку уже ВО ВРЕМЯ ВЫПОЛНЕНИЯ (ещё говорят, что ошибка получена "в Runtime").
//  Ошибка будет: java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
//  Согласитесь, не самое приятное.
//  И всё это потому, что компилятор — не искусcтвенный интеллект и он не может угадать всё, что подразумевает программист.
//  Чтобы рассказать компилятору подробнее о своих намерениях, какие типы мы собираемся использовать, в Java SE 5 ввели дженерики.
//  Исправим наш вариант, подсказав компилятору, что же мы хотим:
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Hello!");
//        list.add(123);  // здесь будет ошибка при компиляции - тип должен быть String, а указан int
        for (Object str : list) {
            System.out.println(str);
        }
    }
}
// Как мы видим, нам больше не нужно приведение к String. Кроме того, у нас появились угловые скобки (angle brackets),
// которые обрамляют дженерики. Теперь компилятор не даст скомпилировать класс,
// пока мы не удалим добавление 123 в список, т.к. это Integer. Он нам так и скажет.
// Многие называют дженерики "синтаксическим сахаром". И они правы, так как дженерики действительно при компиляции
// станут теми самыми кастами. Посмотрим на байткод скомпилированных классов: с кастом вручную и с использованием дженериков:
// После компиляции какая-либо информация о дженериках стирается. Это называется "Стирание типов" или "Type Erasure".
// Стирание типов и дженерики сделаны так, чтобы обеспечить обратную совместимость со старыми версиями JDK,
// но при этом дать возможность помогать компилятору с определением типа в новых версиях Java.

