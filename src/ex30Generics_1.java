/*
Обобщения позволяют не указывать конкретный тип, который будет использоваться.
Поэтому определим класс Account как обобщенный
class Account<T> {
    private T id;
    private int sum;

    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }

    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}

С помощью буквы T в определении класса class Account<T> мы указываем, что данный тип T будет использоваться этим классом.
Параметр T в угловых скобках называется универсальным параметром, так как вместо него можно подставить любой тип.
При этом пока мы не знаем, какой именно это будет тип: String, int или какой-то другой. Причем буква T выбрана условно,
это может и любая другая буква или набор символов.

После объявления класса мы можем применить универсальный параметр T: так далее в классе объявляется переменная этого типа,
которой затем присваивается значение в конструкторе.

Метод getId() возвращает значение переменной id, но так как данная переменная представляет тип T,
то данный метод также возвращает объект типа T: public T getId().

При определении переменной даннного класса и создании объекта после имени класса в угловых скобках нужно указать,
какой именно тип будет использоваться вместо универсального параметра. При этом надо учитывать,
что они работают только с объектами, но не работают с примитивными типами. То есть мы можем написать Account<Integer>,
но не можем использовать тип int или double, например, Account<int>.
Вместо примитивных типов надо использовать классы-обертки: Integer вместо int, Double вместо double и т.д.

Например, первый объект будет использовать тип String, то есть вместо T будет подставляться String:
1) Account<String> acc1 = new Account<String>("2345", 5000);
В этом случае в качестве первого параметра в конструктор передается строка.
А второй объект использует тип int (Integer):
2) Account<Integer> acc2 = new Account<Integer>(2345, 5000);

Преимущества дженериков в Java
1. Повторное использование кода.
Вы можете составить стратегию, класс или интерфейс один раз и использовать их для любого типа или любым другим способом.

2. Кастинг отдельных типов не требуется.
По сути, вы восстанавливаете информацию из ArrayList каждый раз, когда вам нужно ее типизировать.
Типирование при каждой задаче восстановления является серьезной задачей.
Чтобы искоренить этот подход, были введены дженерики.

3. Реализация неуниверсального алгоритма.
Он может рассчитывать алгоритмы, которые работают с различными типами элементов, которые также являются безопасными типами.
Источник: https://java-blog.ru/osnovy/generics-java
 */
public class ex30Generics_1 {

    public static void main(String[] args) {

        Account<String> acc1 = new Account<String>("2345", 5000);
        String acc1Id = acc1.getId();
        System.out.println(acc1Id);

        Account<Integer> acc2 = new Account<Integer>(2345, 5000);
        Integer acc2Id = acc2.getId();
        System.out.println(acc2Id);
    }
}
class Account<T>{

    private T id;
    private int sum;

    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }

    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}