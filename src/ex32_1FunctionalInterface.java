/*
Определение функциональных интерфейсов
Ты наверняка знаком с ситуацией, когда в разных частях программы должен выполняться один и тот же код,
а различие лишь в данных, которые он будет обрабатывать.
И тогда кусок кода не дублируют, а поступают хитрее — создают метод. И этот метод вызывают в нужных местах.

Передача простых параметров в виде примитивов или объектов труда обычно не составляет.
Но порой в метод требуется передавать не просто переменную, а исполняемый код.

Например, нам нужен метод, который работает с элементами массива, причём только с теми, что соответствуют некоторому условию.
А само условие во время написания метода мы можем не знать (или оно будет меняться).

Как поступить? Передавать реализующий условие код с помощью параметра метода!
Да, в Java начиная с восьмой версии можно подобное делать. И сейчас ты узнаешь, как.

Пример
Напишем методы, возвращающие сумму и произведение двух чисел.

private int sum(int a, int b) {
    return a+b;
}
private int mult(int a, int b) {
    return a*b;
}

А теперь объединим их в один — processTwoNumbers. Он будет принимать два параметра-числа и код, который их обрабатывает.

private int processTwoNumbers(int a, int b, [сюда передаётся код])

Для выполнения метода sum третий параметр примет в качестве аргумента действие a+b, а для выполнения метода mult — a*b.
Обратите внимание, что третьим аргументом может быть передан не любой код, а только тот,
который принимает на вход два параметра заданного типа (у нас int) и возвращает переменную нужного типа (int).
Значит, надо как-то сообщить об этом компилятору - запретить будущим разработчикам передавать неподходящий код (вроде a+b+c).
Поможет в этом сигнатура метода. Она станет третьим параметром в нашем методе processTwoNumbers:

private int processTwoNumbers(int a, int b, [сигнатура метода])

Но как записать третий параметр, чтобы сигнатура самого метода processTwoNumbers не разрослась до нечитабельности?
Этот вопрос разработчики Java решили изящно. Они придумали функциональные интерфейсы.

Что такое функциональный интерфейс
Функциональный интерфейс — это интерфейс, который содержит ровно один абстрактный метод, то есть описание метода без тела.
Статические методы и методы по умолчанию при этом не в счёт, их в функциональном интерфейсе может быть сколько угодно.
Когда параметром метода является функциональный интерфейс, при вызове этого метода одним из аргументов должен быть блок кода.
Передаваемый блок кода должен удовлетворять следующему условию: его сигнатура должна совпадать с сигнатурой единственного
абстрактного метода функционального интерфейса.

Звучит непросто, поясним на примере.
@FunctionalInterface
public interface ToIntBiFunction<T, U> {

    // Applies this function to the given arguments.
    // @param t the first function argument
    // @param u the second function argument
    // @return the function result

   int applyAsInt(T t, U u);
   }

Важно. В Java есть несколько готовых функциональных интерфейсов с разным числом и типами входных-выходных параметров.
(Как раз из таких ToIntBiFunction выше)
А если мы создаём новый функциональный интерфейс, то важно не забыть аннотацию
@FunctionalInterface.
Увидев её, компилятор проверит, что интерфейс и правда является функциональным.

Функциональный интерфейс ToIntBiFunction<T, U> подходит к тому примеру, с которого мы начинали.
Это значит, что мы можем передать в него аргументом код, который:
— принимает на вход два параметра (T t, U u). T и U указывают на то, что аргументы могут быть разных типов.
Например, Long и String. Для нас это даже избыточно, у нас они одного типа — int;
— возвращает значение типа int.

Вот что получится:
public void processTwoNumbers(int a, int b, ToIntBiFunction<Integer, Integer> function) {
//code
}
Кусочек ToIntBiFunction<Integer, Integer> говорит: передавай сюда метод с такой же сигнатурой, как у метода внутри меня.

Чтобы внутри метода processTwoNumbers выполнить переданный код, нужно вызвать метод из функционального интерфейса:
public void processTwoNumbers(int a, int b, ToIntBiFunction<Integer, Integer> function) {
    function.applyAsInt(a, b);
}
*/


import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.function.ToIntBiFunction;
import java.util.function.UnaryOperator;
import static java.util.function.UnaryOperator.identity;

public class ex32_1FunctionalInterface {
    public static void main(String[] args) throws IOException {
        System.out.println(processTwoNumbers(20, 40, ex32_1FunctionalInterface::mult)); // 800

        List<String> list = new ArrayList<>(List.of("Hello", "Cat", "Java", "Bag"));
        System.out.println(list);
        list.removeIf(new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.length() > 3;
            }
        });
        System.out.println(list);
/*
//////////////////////////// КУРС СО СТЕПИКА ///////////////////////////////////////
ИНТЕРФЕЙС НАЗЫВАЕТСЯ ФУНКЦИОНАЛЬНЫМ
если в нем ровно один абстрактный метод

package java.util;

@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
    // any number of default or static methods
}

Подчеркнуть это и проверить на стадии компиляции можно при помощи аннотации
@FunctionalInterface
Дефолт методы и статические не в счет - их в функциональном интерфейсе может быть сколько угодно
как и статических полей!!!

ЗАЧЕМ В ЯЗЫК БЫЛИ ДОБАВЛЕНЫ ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ
Дело в том, что в java нет указателей на функцию(С, С++) или делегатов(С#)
Поэтому, когда в java требуется передать в метод кусочек программной логики,
метод объявляется как принимающий экземпляр какого-либо класса или интерфейса
А в месте вызова метода такой экземпляр нужно как-то создать,
зачастую объявив там же анонимный класс, с подходящей реализацией метода
*/
        File directory = new File("C:\\JavaEx");
        File[] javaSourceFiles = directory.listFiles(
                new FileFilter() {
                    @Override
                    public boolean accept(File file) {
                        return file.getName().endsWith(".java");
                    }
                });
        // Например, с условием для фильтрации файлов, до Java 7 приходилось записывать в таком виде
        // Здесь все, кроме 1 строчки - избыточно
        // Содержательная часть - логика фильтрации - только 1 возвращающее значение выражение
        // А все остальное - технические детали - шелуха
        // Это очень неудобно, поэтому нужны были лямбда-выражения или замыкания
        // Какой-то компактный синтаксис для передачи куска кода
        // В качестве параметра в другой код
        // По этому поводу java-программисты очень завидовали другим языкам
        // Есть даже шутка, что java сделала замыкания популярными, не поддерживая их

        // И вот в java 8 было введено такое понятие как функциональный интерфейс
        // Именно они помогли избавиться от монструозного синтаксиса с анонимными классами
        // И использовать компактные лямбда-выражения и ссылки на методы
        // Это открыло возможность писать на java программы в функциональном стиле,
        // характерном для функциональных языков программирования
        // когда программа записывается как последовательное применение функции
        // к некоторым значениям и другим функциям,
        // а не как сложная структура из циклов, условных операторов
        // и перекладывания значений переменных туда-сюда

        // package java.io;
        // @Functional interface
        // public interface FileFilter {
        //      boolean accept(File pathname);
        // }
        // java util Comparator тоже существуют в языке давно

        // В java 8 они стали функциональными
        // Появился целый пакет функциональных интерфейсов (более 40)

        // ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ ЧЕТКО ДЕЛЯТСЯ НА 5 СЕМЕЙСТВ

        // 1) Первое семейство - Consumer (потребитель)
        // package java.util.function;
        // @FunctionalInterface
        // public interface Consumer<T> {
        //      void accept(T t);
        // }
        // Это те, кто принимает какое-то значение, выполняет действие, но ничего не возвращает взамен
        // Этот консьюмер параметризован дженериком - типом объекта, который он будет принимать
        // Есть еще отдельные интерфейсы IntConsumer, LongConsumer, DoubleConsumer
        // принимающие значения соответствующих примитивных типов
        // Они существуют потому, что дженерики в java не могут параметризоваться примитивами
        // Разработчикам java-библиотеки пришлось пойти на определенный копи-паст
        // А еще бывают консьюмеры, принимающие по 2 параметра
        // Интерфейс BiConsumer<T, U> с двумя дженерик-параметрами
        // И он ничего не возвращает void accept(T, U)

        // 2) Второе семейство - Supplier (поставщик)
        // package java.util.function;
        // @FunctionalInterface
        // public interface Supplier<T> {
        //      T get;
        // }
        // Они не принимают ничего в качестве параметра,
        // а просто возвращают какое-то значение
        // Это дженерик-сэпплайер, параметризованный тем типом, который он возвращает.
        // Есть еще отдельно булевский сэпплайер BooleanS, IntS, LongS, DoubleS

        // 3) Третье семейство - предикаты
        // package java.util.function;
        // @FunctionalInterface
        // public interface Predicate<T> {
        //      boolean test(T t);
        // }
        // Их функциональный метод принимает значение какого-то типа
        // а наружу выдает булевское значение истина-ложь
        // Есть специализированные предикаты для интов IntP, LongP, DoubleP
        // Есть разновидность предиката, принимающего сразу 2 параметра - BiPredicate

        // 4) Четвертое семейство - самое плодовитое - функции
        // package java.util.function;
        // @FunctionalInterface
        // public interface Function<T, R> {
        //      R apply(T t);
        // }
        // функция принимает аргумент одного типа T, выполняет действие, и возвращает значение какого-то другого типа R
        // В общем случае эти типы разные
        // Бывают функции, принимающие 2 параметра BiFunction
        // И масса специализаций функции, где на месте одного или обеих параметров стоят примитивы
        // DoubleF: double -> T Функция принимает дабл и возвращает объект
        // LongToIntF: long -> int Функция принимает лонг и возвращает инт
        // ToIntF: Т -> int Функция принимает объект и возвращает инт
        // И таких специализаций еще много

        // 5) Пятое семейство - операторы
        // package java.util.function;
        // @FunctionalInterface
        // public interface UnaryOperator<T> extends Function<T, T> {
        //      // apply is inherited from Function
        // }
        // Операторы - это частный случай функции,
        // Когда на входе и на выходе значение одного и того же типа
        // Унарный оператор принимает один параметр
        // А бинарный оператор - два - BinaryOperator
        // Заведены отдельные интерфейсы над унарными и бинарными примитивными Int Long Double

        // В нестандартной ситуации - функция 3 параметров - придется писать такой интерфейс

        /////////////////////////// 3 СПОСОБА ИНСТАНЦИРОВАТЬ ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ ///////////////////////////////////////
        /////////// 1) Можно честно завести именованный или анонимный класс, реализующий интерфейс
        // class IntSquare implements IntUnaryOperator {
        //     @Override
        //     public int applyAsInt (int operand) {
        //         return operand * operand;
        //     }
        // }
        // Но это громоздко
        // Если данный класс не будет переиспользоваться, то совершенно излишне


        /////////// 2) Можно использовать лямбда-выражение
        // IntUnaryOperator square = x -> {
        //     return x * x;
        // }
        // IntConsumer print = x -> System.out.print(x)
        // IntUnaryOperator cube = x -> x * x * x;
        // Компилятор знает ожидаемый интерфейс
        // И поэтому не требует от нас повторять имя этого интерфейса,
        // а также имя метода, типы параметров и тип возвращаемого значения
        // справа от знака равенства
        // Мы просто объявляем имена параметров и тело метода - непосредственно исполняемый код
        // Если тело метода состоит из единственного выражения и это не return,
        // То фигурные скобки вокруг тела метода можно опустить, а также даже ключевое слово return убираем
        /////////  К каким переменным и как можно обращаться в теле лямбда-выражения?
        // public class Demo {
        //     private int counter;
        //     public void foo() {
        //         IntUnaryOperator square = x -> x * x;
        //         IntSupplier sequence = () -> counter++;
        //         int bonus = 10;
        //         IntUnaryOperator bonus Adder = (x) -> x + bonus;
        //     }
        // }
        // Можно обращаться к параметрам лямбды (локальным переменным) x
        // а также свободно объявлять и использовать внутри лямбда-выражения любые дополнительные локальные переменные
        // можно обращаться к полям того класса, внутри которого объявлена лямбда
        // причем их можно как читать, так и писать
        // Можно обращаться к переменным, объявленным внутри того метода, где создана лямбда
        // Но здесь есть ограничение - переменные должны быть эффективно-финальными
        // - значение им должно быть присвоено ровно 1 раз до создания лямбды
        // после чего меняться оно меняться оно уже не может
        // это то же самое, что если бы мы написали перед ними ключевое слово final int bonus = 10
        // его можно написать, но компилятор этого не требует
        // Отсюда правило - из лямбды нельзя присваивать новые значения переменным содержащего ее класса или метода
        // Для обхода этого правила иногда используют трюк с массивом единичной длины
        // int[] counter = new int[] {0};
        // IntSupplier sequence = () -> counter[0]++;
        // ссылка на массив является эффективно-финальной, но на содержимое массива это ограничение не распространяется
        // и его можно обновлять


        //////////// 3) Функциональный интерфейс можно инстанцировать при помощи ссылки на метод
        // - ToIntFunction<String> intParser = Integer::parseInt;
        // - Consumer<Object> printer = System.out::println;
        // - Function<Object, String> objectToString = Object::toString;
        // - IntFunction<String[]> arrayAllocator = String[]::new;
        // Это самый простой на вид способ, но у него есть несколько нюансов
        // 1) Мы можем ссылаться на статический метод, указывая имя класса, два двоеточия, имя статического метода
        // 2) Или мы можем ссылаться на нестатический метод, указывая конкретный объект класса, два двоеточия, имя нестатического метода
        // 3) Еще один способ сослаться на нестатический метод любого объекта класса Object - Object, два двоеточия, имя нестатического метода
        // Но тогда первый передаваемый в месте вызова функционального интерфейса параметр будет тем самым объектом,
        // на котором данный нестатический метод будет вызван
        // 4) Еще можно ссылаться на конструктор - пишут имя класса, два двоеточия, и ключевое слово new


        ////////////////////////// МЕТОДЫ ИНТЕРФЕЙСОВ //////////////////////////////////////////////
        // Кроме главного абстрактного метода, у функциональных интерфейсов еще есть много статических и дефолтных методов
        // позволяющих делать разные полезные вещи

        // IntPredicate isOdd = x -> x % 2 != 0;
        // 1) Если у нас есть некоторый предикат, то обратный ему можно получить с помощью метода negate()
        // IntPredicate isEven = isOdd.negate();

        // IntPredicate p1 = ..., p2 = ...;
        // 2) Если у нас есть 2 предиката, то можно построить их конъюнкцию при помощи метода and
        // IntPredicate p3 = p1.and(p2);

        // 3) Мы можем скомбинировать 2 консьюмера в один,
        // который вызовет сначала первое действие, затем второе
        // В данном случае - напечатает объект в консоль, а потом добавит в список
        // Consumer<Object> printer = system.out::println;

        // List<Object> objects = new ArrayList<>();
        // Consumer<Object> collector = objects::add;

        // Consumer<Object> combinedConsumer = printer.andThen(collector);

        // 3.1) Похожим образом можно строить композиции функций - при помощи методов and-then и compose
        // Разница между этими методами в порядке применения
        // DoubleUnaryOperator square = x -> x * x;
        // DoubleUnaryOperator sin = Math::sin;

        // DoubleUnaryOperator complexFunction1 = sin.andThen(square); // sin^2(x) - выполняем функ 1 с аргументом, затем функ 2 с результатом

        // DoubleUnaryOperator complexFunction2 = sin.compose(square); // sin(x^2) - выполняем функ 2 с аргументом, затем функ 1 с результатом

        /////////////////// 4) Еще один пример
        // Самый плодовитый на методы интерфейс - это Comparator
        // Comparator<Double> absoluteValueComparator =
        //         (a, b) -> Double.compare(
        //                 Math.abs(a), Math.abs(b));

        // Comparator <Double> absoluteValueComparator2 =
        //         Comparator.comparing(
        //                 Math::abs, Double::compare);


    }
    private static int sum(int a, int b) {
        return a + b;
    }

    private static int mult(int a, int b) {
        return a * b;
    }

    private static int processTwoNumbers(int a, int b, ToIntBiFunction<Integer, Integer> function) {
        return function.applyAsInt(a, b);
    }
}
class SimpleGen {
    private int number;

    public SimpleGen(int number) {
        super();
        this.number = number;
    }
    public SimpleGen() {
        super();
    }

    public int getNumber() {
        int temp = number;
        number = number + 1;
        return temp;
    }
}
